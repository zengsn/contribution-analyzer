[ {
  "id" : "4989802644",
  "type" : "IssueCommentEvent",
  "actor" : {
    "id" : 8851265,
    "login" : "tomenden",
    "display_login" : "tomenden",
    "gravatar_id" : "",
    "url" : "https://api.github.com/users/tomenden",
    "avatar_url" : "https://avatars.githubusercontent.com/u/8851265?"
  },
  "repo" : {
    "id" : 47071941,
    "name" : "yelouafi/redux-saga",
    "url" : "https://api.github.com/repos/yelouafi/redux-saga"
  },
  "payload" : {
    "action" : "created",
    "issue" : {
      "url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/669",
      "repository_url" : "https://api.github.com/repos/yelouafi/redux-saga",
      "labels_url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/669/labels{/name}",
      "comments_url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/669/comments",
      "events_url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/669/events",
      "html_url" : "https://github.com/yelouafi/redux-saga/issues/669",
      "id" : 193456838,
      "number" : 669,
      "title" : "All-or-nothing cancellation - is spawning the correct approach?",
      "user" : {
        "login" : "tomenden",
        "id" : 8851265,
        "avatar_url" : "https://avatars.githubusercontent.com/u/8851265?v=3",
        "gravatar_id" : "",
        "url" : "https://api.github.com/users/tomenden",
        "html_url" : "https://github.com/tomenden",
        "followers_url" : "https://api.github.com/users/tomenden/followers",
        "following_url" : "https://api.github.com/users/tomenden/following{/other_user}",
        "gists_url" : "https://api.github.com/users/tomenden/gists{/gist_id}",
        "starred_url" : "https://api.github.com/users/tomenden/starred{/owner}{/repo}",
        "subscriptions_url" : "https://api.github.com/users/tomenden/subscriptions",
        "organizations_url" : "https://api.github.com/users/tomenden/orgs",
        "repos_url" : "https://api.github.com/users/tomenden/repos",
        "events_url" : "https://api.github.com/users/tomenden/events{/privacy}",
        "received_events_url" : "https://api.github.com/users/tomenden/received_events",
        "type" : "User",
        "site_admin" : false
      },
      "labels" : [ {
        "id" : 293021649,
        "url" : "https://api.github.com/repos/yelouafi/redux-saga/labels/question",
        "name" : "question",
        "color" : "cc317c",
        "default" : true
      } ],
      "state" : "open",
      "locked" : false,
      "assignee" : null,
      "assignees" : [ ],
      "milestone" : null,
      "comments" : 6,
      "created_at" : "2016-12-05T10:11:09Z",
      "updated_at" : "2016-12-08T13:11:09Z",
      "closed_at" : null,
      "body" : "In my App I have a toggle which sends some data to the server when its value changes.\r\nTo ensure that the data is not sent too many times, I `debounce` the requests by 300 ms. Here is an example:\r\n```javascript\r\nfunction* watchChangeAction() {\r\n    let task;\r\n    while (true) {\r\n        const action = yield take(actionTypes.CHANGE);\r\n        if (task) {\r\n            yield cancel(task);\r\n        }\r\n        task = yield fork(updateDataInServer, action);\r\n    }\r\n\r\n}\r\n\r\nfunction* updateDataInServer(action) {\r\n    try {\r\n        // debounce 300 ms\r\n        yield call(delay, 300);\r\n\r\n       //retrieve key from the store\r\n        const key = yield select(selectors.getKey);\r\n        const newSettings = yield select(selectors.getSettingsItems);\r\n\r\n        const response = yield call(serverSettings.update, newSettings, key);\r\n        const responseKey = serverSelectors.getKey(response);\r\n       // dispatch action with responseKey, which is stored for later user\r\n        yield put(actions.saved(responseKey));\r\n\r\n    } \r\n//...\r\n }\r\n```\r\n\r\nThe issue is that my server returns a distinct key in every response that it makes. In order to be able to call the server, I must provide it the latest key in my request, which I maintain inside myStore (see above `const key = yield select(selectors.getKey)`).\r\n\r\nThe problem occurs when the cancellation is done before the response from the server is received. \r\nWhat happens is that the request had already gone out (thus a new key has been provided), but by the time the response arrives the task is already cancelled, and thus the response key is never stored, and it is not possible to send any more requests.\r\n\r\nAfter investigating the issue, I decided to go with `spawn` in order to insure an all-or-nothing- approach. If the task is cancelled before the request has gone out then it will be ignored, however if the request had occurred, the entire process will happen. So `updateDataInServer` now looks like this:\r\n\r\n```javascript\r\n try {\r\n      // debounce 300 ms\r\n        yield call(delay, 300);\r\n\r\n        const key = yield select(selectors.getKey);\r\n        const newSettings = yield select(selectors.getSettingsItems);\r\n\r\n         yield spawn(function*() {\r\n               const response = yield call(serverSettings.update, newSettings, key);\r\n               const responseKey = serverSelectors.getKey(response);\r\n               yield put(actions.saved(responseKey));\r\n        });\r\n\r\n    } \r\n//...\r\n```\r\n\r\nI was wondering whether this is the correct approach. @yelouafi - I would appreciate your feedback.\r\nI upgraded from version 0.95 in order to get `spawn` because I could not find a different way to solve this issue. Can the behavior I want be achieved with that version?\r\n\r\nThanks"
    },
    "comment" : {
      "url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/comments/265736350",
      "html_url" : "https://github.com/yelouafi/redux-saga/issues/669#issuecomment-265736350",
      "issue_url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/669",
      "id" : 265736350,
      "user" : {
        "login" : "tomenden",
        "id" : 8851265,
        "avatar_url" : "https://avatars.githubusercontent.com/u/8851265?v=3",
        "gravatar_id" : "",
        "url" : "https://api.github.com/users/tomenden",
        "html_url" : "https://github.com/tomenden",
        "followers_url" : "https://api.github.com/users/tomenden/followers",
        "following_url" : "https://api.github.com/users/tomenden/following{/other_user}",
        "gists_url" : "https://api.github.com/users/tomenden/gists{/gist_id}",
        "starred_url" : "https://api.github.com/users/tomenden/starred{/owner}{/repo}",
        "subscriptions_url" : "https://api.github.com/users/tomenden/subscriptions",
        "organizations_url" : "https://api.github.com/users/tomenden/orgs",
        "repos_url" : "https://api.github.com/users/tomenden/repos",
        "events_url" : "https://api.github.com/users/tomenden/events{/privacy}",
        "received_events_url" : "https://api.github.com/users/tomenden/received_events",
        "type" : "User",
        "site_admin" : false
      },
      "created_at" : "2016-12-08T13:11:09Z",
      "updated_at" : "2016-12-08T13:11:09Z",
      "body" : "@Andarist \r\nFirst of all, I'd like to thank you a lot for your assistance, and for recommending channels. It got me to read about this pattern which is extremely powerful, and very suitable for the issue I am facing.\r\nI created a generic solution to create a 'debounce channel', I will be very happy to get your feedback on it. You can see the gist [here](https://gist.github.com/tomenden/a600115fe0549836e85b5503fe3cca84).\r\n\r\nI want to ask specifically regarding [this](https://gist.github.com/tomenden/a600115fe0549836e85b5503fe3cca84#file-debounced-channel-js-L12) line. The reason I am spawning here is because the `debouncedChannel` is being consumed by using [call](https://gist.github.com/tomenden/a600115fe0549836e85b5503fe3cca84#file-debounced-channel-js-L4) (in order to `take` from the channel inside the main saga). I was surprised to see that when using `fork` in `debouncedChannel`, the original saga (`watchChangeAction`) does not immediately resolve. Is this the expected behavior? I understand that `call`ing a `saga` will block until the saga has completed, but was unaware that this is also true for the sagas' non-blocking effects. Is this the expected?\r\n\r\nOnce again, huge thanks!"
    }
  },
  "public" : true,
  "created_at" : "2016-12-08T13:11:10Z"
}, {
  "id" : "4974894972",
  "type" : "IssueCommentEvent",
  "actor" : {
    "id" : 8851265,
    "login" : "tomenden",
    "display_login" : "tomenden",
    "gravatar_id" : "",
    "url" : "https://api.github.com/users/tomenden",
    "avatar_url" : "https://avatars.githubusercontent.com/u/8851265?"
  },
  "repo" : {
    "id" : 47071941,
    "name" : "yelouafi/redux-saga",
    "url" : "https://api.github.com/repos/yelouafi/redux-saga"
  },
  "payload" : {
    "action" : "created",
    "issue" : {
      "url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/669",
      "repository_url" : "https://api.github.com/repos/yelouafi/redux-saga",
      "labels_url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/669/labels{/name}",
      "comments_url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/669/comments",
      "events_url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/669/events",
      "html_url" : "https://github.com/yelouafi/redux-saga/issues/669",
      "id" : 193456838,
      "number" : 669,
      "title" : "All-or-nothing cancellation - is spawning the correct approach?",
      "user" : {
        "login" : "tomenden",
        "id" : 8851265,
        "avatar_url" : "https://avatars.githubusercontent.com/u/8851265?v=3",
        "gravatar_id" : "",
        "url" : "https://api.github.com/users/tomenden",
        "html_url" : "https://github.com/tomenden",
        "followers_url" : "https://api.github.com/users/tomenden/followers",
        "following_url" : "https://api.github.com/users/tomenden/following{/other_user}",
        "gists_url" : "https://api.github.com/users/tomenden/gists{/gist_id}",
        "starred_url" : "https://api.github.com/users/tomenden/starred{/owner}{/repo}",
        "subscriptions_url" : "https://api.github.com/users/tomenden/subscriptions",
        "organizations_url" : "https://api.github.com/users/tomenden/orgs",
        "repos_url" : "https://api.github.com/users/tomenden/repos",
        "events_url" : "https://api.github.com/users/tomenden/events{/privacy}",
        "received_events_url" : "https://api.github.com/users/tomenden/received_events",
        "type" : "User",
        "site_admin" : false
      },
      "labels" : [ {
        "id" : 293021649,
        "url" : "https://api.github.com/repos/yelouafi/redux-saga/labels/question",
        "name" : "question",
        "color" : "cc317c",
        "default" : true
      } ],
      "state" : "open",
      "locked" : false,
      "assignee" : null,
      "assignees" : [ ],
      "milestone" : null,
      "comments" : 3,
      "created_at" : "2016-12-05T10:11:09Z",
      "updated_at" : "2016-12-06T08:43:59Z",
      "closed_at" : null,
      "body" : "In my App I have a toggle which sends some data to the server when its value changes.\r\nTo ensure that the data is not sent too many times, I `debounce` the requests by 300 ms. Here is an example:\r\n```javascript\r\nfunction* watchChangeAction() {\r\n    let task;\r\n    while (true) {\r\n        const action = yield take(actionTypes.CHANGE);\r\n        if (task) {\r\n            yield cancel(task);\r\n        }\r\n        task = yield fork(updateDataInServer, action);\r\n    }\r\n\r\n}\r\n\r\nfunction* updateDataInServer(action) {\r\n    try {\r\n        // debounce 300 ms\r\n        yield call(delay, 300);\r\n\r\n       //retrieve key from the store\r\n        const key = yield select(selectors.getKey);\r\n        const newSettings = yield select(selectors.getSettingsItems);\r\n\r\n        const response = yield call(serverSettings.update, newSettings, key);\r\n        const responseKey = serverSelectors.getKey(response);\r\n       // dispatch action with responseKey, which is stored for later user\r\n        yield put(actions.saved(responseKey));\r\n\r\n    } \r\n//...\r\n }\r\n```\r\n\r\nThe issue is that my server returns a distinct key in every response that it makes. In order to be able to call the server, I must provide it the latest key in my request, which I maintain inside myStore (see above `const key = yield select(selectors.getKey)`).\r\n\r\nThe problem occurs when the cancellation is done before the response from the server is received. \r\nWhat happens is that the request had already gone out (thus a new key has been provided), but by the time the response arrives the task is already cancelled, and thus the response key is never stored, and it is not possible to send any more requests.\r\n\r\nAfter investigating the issue, I decided to go with `spawn` in order to insure an all-or-nothing- approach. If the task is cancelled before the request has gone out then it will be ignored, however if the request had occurred, the entire process will happen. So `updateDataInServer` now looks like this:\r\n\r\n```javascript\r\n try {\r\n      // debounce 300 ms\r\n        yield call(delay, 300);\r\n\r\n        const key = yield select(selectors.getKey);\r\n        const newSettings = yield select(selectors.getSettingsItems);\r\n\r\n         yield spawn(function*() {\r\n               const response = yield call(serverSettings.update, newSettings, key);\r\n               const responseKey = serverSelectors.getKey(response);\r\n               yield put(actions.saved(responseKey));\r\n        });\r\n\r\n    } \r\n//...\r\n```\r\n\r\nI was wondering whether this is the correct approach. @yelouafi - I would appreciate your feedback.\r\nI upgraded from version 0.95 in order to get `spawn` because I could not find a different way to solve this issue. Can the behavior I want be achieved with that version?\r\n\r\nThanks"
    },
    "comment" : {
      "url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/comments/265092930",
      "html_url" : "https://github.com/yelouafi/redux-saga/issues/669#issuecomment-265092930",
      "issue_url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/669",
      "id" : 265092930,
      "user" : {
        "login" : "tomenden",
        "id" : 8851265,
        "avatar_url" : "https://avatars.githubusercontent.com/u/8851265?v=3",
        "gravatar_id" : "",
        "url" : "https://api.github.com/users/tomenden",
        "html_url" : "https://github.com/tomenden",
        "followers_url" : "https://api.github.com/users/tomenden/followers",
        "following_url" : "https://api.github.com/users/tomenden/following{/other_user}",
        "gists_url" : "https://api.github.com/users/tomenden/gists{/gist_id}",
        "starred_url" : "https://api.github.com/users/tomenden/starred{/owner}{/repo}",
        "subscriptions_url" : "https://api.github.com/users/tomenden/subscriptions",
        "organizations_url" : "https://api.github.com/users/tomenden/orgs",
        "repos_url" : "https://api.github.com/users/tomenden/repos",
        "events_url" : "https://api.github.com/users/tomenden/events{/privacy}",
        "received_events_url" : "https://api.github.com/users/tomenden/received_events",
        "type" : "User",
        "site_admin" : false
      },
      "created_at" : "2016-12-06T08:43:59Z",
      "updated_at" : "2016-12-06T08:43:59Z",
      "body" : "@Andarist \r\nThanks for your help, but unfortunately this approach does not seem to work either.\r\nPerhaps I did not clarify my use-case well enough. If I attempt to make two requests at the same time **one of them will necessarily fail**. I must wait for the response to come back before dispatching the second request, in order for the key that I send to be correct.\r\n\r\nHere is the scenario in which this fails:\r\nUser changes data - `debounced` wins the race, and thus the task is forked. All is well and nice.\r\nAfter some time (>300ms) the user changes the data again. `debounced` wins the race, yet again, and the second request is sent. However, the server did not yet respond to the first request, the key is not updated in the store, and thus the second request fails.\r\n\r\nHope this makes sense now. Currently my thought is perhaps to change the logic a bit to also rely on the response action to have occurred (i.e - in case a request is made while another request is in progress, the second request will wait for the `saved` action before sending itself.\r\n\r\nI am also checking a way of making the solution more generic, but without much luck in the meanwhile.\r\n\r\nWhat do you think?\r\n\r\nThanks in advance!"
    }
  },
  "public" : true,
  "created_at" : "2016-12-06T08:44:00Z"
}, {
  "id" : "4969434603",
  "type" : "IssueCommentEvent",
  "actor" : {
    "id" : 8851265,
    "login" : "tomenden",
    "display_login" : "tomenden",
    "gravatar_id" : "",
    "url" : "https://api.github.com/users/tomenden",
    "avatar_url" : "https://avatars.githubusercontent.com/u/8851265?"
  },
  "repo" : {
    "id" : 47071941,
    "name" : "yelouafi/redux-saga",
    "url" : "https://api.github.com/repos/yelouafi/redux-saga"
  },
  "payload" : {
    "action" : "created",
    "issue" : {
      "url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/669",
      "repository_url" : "https://api.github.com/repos/yelouafi/redux-saga",
      "labels_url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/669/labels{/name}",
      "comments_url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/669/comments",
      "events_url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/669/events",
      "html_url" : "https://github.com/yelouafi/redux-saga/issues/669",
      "id" : 193456838,
      "number" : 669,
      "title" : "All-or-nothing cancellation - is spawning the correct approach?",
      "user" : {
        "login" : "tomenden",
        "id" : 8851265,
        "avatar_url" : "https://avatars.githubusercontent.com/u/8851265?v=3",
        "gravatar_id" : "",
        "url" : "https://api.github.com/users/tomenden",
        "html_url" : "https://github.com/tomenden",
        "followers_url" : "https://api.github.com/users/tomenden/followers",
        "following_url" : "https://api.github.com/users/tomenden/following{/other_user}",
        "gists_url" : "https://api.github.com/users/tomenden/gists{/gist_id}",
        "starred_url" : "https://api.github.com/users/tomenden/starred{/owner}{/repo}",
        "subscriptions_url" : "https://api.github.com/users/tomenden/subscriptions",
        "organizations_url" : "https://api.github.com/users/tomenden/orgs",
        "repos_url" : "https://api.github.com/users/tomenden/repos",
        "events_url" : "https://api.github.com/users/tomenden/events{/privacy}",
        "received_events_url" : "https://api.github.com/users/tomenden/received_events",
        "type" : "User",
        "site_admin" : false
      },
      "labels" : [ ],
      "state" : "open",
      "locked" : false,
      "assignee" : null,
      "assignees" : [ ],
      "milestone" : null,
      "comments" : 1,
      "created_at" : "2016-12-05T10:11:09Z",
      "updated_at" : "2016-12-05T13:22:43Z",
      "closed_at" : null,
      "body" : "In my App I have a toggle which sends some data to the server when its value changes.\r\nTo ensure that the data is not sent too many times, I `debounce` the requests by 300 ms. Here is an example:\r\n```javascript\r\nfunction* watchChangeAction() {\r\n    let task;\r\n    while (true) {\r\n        const action = yield take(actionTypes.CHANGE);\r\n        if (task) {\r\n            yield cancel(task);\r\n        }\r\n        task = yield fork(updateDataInServer, action);\r\n    }\r\n\r\n}\r\n\r\nfunction* updateDataInServer(action) {\r\n    try {\r\n        // debounce 300 ms\r\n        yield call(delay, 300);\r\n\r\n       //retrieve key from the store\r\n        const key = yield select(selectors.getKey);\r\n        const newSettings = yield select(selectors.getSettingsItems);\r\n\r\n        const response = yield call(serverSettings.update, newSettings, key);\r\n        const responseKey = serverSelectors.getKey(response);\r\n       // dispatch action with responseKey, which is stored for later user\r\n        yield put(actions.saved(responseKey));\r\n\r\n    } \r\n//...\r\n }\r\n```\r\n\r\nThe issue is that my server returns a distinct key in every response that it makes. In order to be able to call the server, I must provide it the latest key in my request, which I maintain inside myStore (see above `const key = yield select(selectors.getKey)`).\r\n\r\nThe problem occurs when the cancellation is done before the response from the server is received. \r\nWhat happens is that the request had already gone out (thus a new key has been provided), but by the time the response arrives the task is already cancelled, and thus the response key is never stored, and it is not possible to send any more requests.\r\n\r\nAfter investigating the issue, I decided to go with `spawn` in order to insure an all-or-nothing- approach. If the task is cancelled before the request has gone out then it will be ignored, however if the request had occurred, the entire process will happen. So `updateDataInServer` now looks like this:\r\n\r\n```javascript\r\n try {\r\n      // debounce 300 ms\r\n        yield call(delay, 300);\r\n\r\n        const key = yield select(selectors.getKey);\r\n        const newSettings = yield select(selectors.getSettingsItems);\r\n\r\n         yield spawn(function*() {\r\n               const response = yield call(serverSettings.update, newSettings, key);\r\n               const responseKey = serverSelectors.getKey(response);\r\n               yield put(actions.saved(responseKey));\r\n        });\r\n\r\n    } \r\n//...\r\n```\r\n\r\nI was wondering whether this is the correct approach. @yelouafi - I would appreciate your feedback.\r\nI upgraded from version 0.95 in order to get `spawn` because I could not find a different way to solve this issue. Can the behavior I want be achieved with that version?\r\n\r\nThanks"
    },
    "comment" : {
      "url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/comments/264852518",
      "html_url" : "https://github.com/yelouafi/redux-saga/issues/669#issuecomment-264852518",
      "issue_url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/669",
      "id" : 264852518,
      "user" : {
        "login" : "tomenden",
        "id" : 8851265,
        "avatar_url" : "https://avatars.githubusercontent.com/u/8851265?v=3",
        "gravatar_id" : "",
        "url" : "https://api.github.com/users/tomenden",
        "html_url" : "https://github.com/tomenden",
        "followers_url" : "https://api.github.com/users/tomenden/followers",
        "following_url" : "https://api.github.com/users/tomenden/following{/other_user}",
        "gists_url" : "https://api.github.com/users/tomenden/gists{/gist_id}",
        "starred_url" : "https://api.github.com/users/tomenden/starred{/owner}{/repo}",
        "subscriptions_url" : "https://api.github.com/users/tomenden/subscriptions",
        "organizations_url" : "https://api.github.com/users/tomenden/orgs",
        "repos_url" : "https://api.github.com/users/tomenden/repos",
        "events_url" : "https://api.github.com/users/tomenden/events{/privacy}",
        "received_events_url" : "https://api.github.com/users/tomenden/received_events",
        "type" : "User",
        "site_admin" : false
      },
      "created_at" : "2016-12-05T13:22:43Z",
      "updated_at" : "2016-12-05T13:22:43Z",
      "body" : "This approach actually does not work either.. If the second call is made after 300 ms and before the response came back, I am facing the same situation of sending the server the wrong key.. What is the right way to make sure that the second request will happen only **after** the first response has returned and the key has been updated in the store?"
    }
  },
  "public" : true,
  "created_at" : "2016-12-05T13:22:44Z"
}, {
  "id" : "4968531493",
  "type" : "IssuesEvent",
  "actor" : {
    "id" : 8851265,
    "login" : "tomenden",
    "display_login" : "tomenden",
    "gravatar_id" : "",
    "url" : "https://api.github.com/users/tomenden",
    "avatar_url" : "https://avatars.githubusercontent.com/u/8851265?"
  },
  "repo" : {
    "id" : 47071941,
    "name" : "yelouafi/redux-saga",
    "url" : "https://api.github.com/repos/yelouafi/redux-saga"
  },
  "payload" : {
    "action" : "opened",
    "issue" : {
      "url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/669",
      "repository_url" : "https://api.github.com/repos/yelouafi/redux-saga",
      "labels_url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/669/labels{/name}",
      "comments_url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/669/comments",
      "events_url" : "https://api.github.com/repos/yelouafi/redux-saga/issues/669/events",
      "html_url" : "https://github.com/yelouafi/redux-saga/issues/669",
      "id" : 193456838,
      "number" : 669,
      "title" : "All-or-nothing cancellation - is spawning the correct approach?",
      "user" : {
        "login" : "tomenden",
        "id" : 8851265,
        "avatar_url" : "https://avatars.githubusercontent.com/u/8851265?v=3",
        "gravatar_id" : "",
        "url" : "https://api.github.com/users/tomenden",
        "html_url" : "https://github.com/tomenden",
        "followers_url" : "https://api.github.com/users/tomenden/followers",
        "following_url" : "https://api.github.com/users/tomenden/following{/other_user}",
        "gists_url" : "https://api.github.com/users/tomenden/gists{/gist_id}",
        "starred_url" : "https://api.github.com/users/tomenden/starred{/owner}{/repo}",
        "subscriptions_url" : "https://api.github.com/users/tomenden/subscriptions",
        "organizations_url" : "https://api.github.com/users/tomenden/orgs",
        "repos_url" : "https://api.github.com/users/tomenden/repos",
        "events_url" : "https://api.github.com/users/tomenden/events{/privacy}",
        "received_events_url" : "https://api.github.com/users/tomenden/received_events",
        "type" : "User",
        "site_admin" : false
      },
      "labels" : [ ],
      "state" : "open",
      "locked" : false,
      "assignee" : null,
      "assignees" : [ ],
      "milestone" : null,
      "comments" : 0,
      "created_at" : "2016-12-05T10:11:09Z",
      "updated_at" : "2016-12-05T10:11:09Z",
      "closed_at" : null,
      "body" : "In my App I have a toggle which sends some data to the server when its value changes.\r\nTo ensure that the data is not sent too many times, I `debounce` the requests by 300 ms. Here is an example:\r\n```javascript\r\nfunction* watchChangeAction() {\r\n    let task;\r\n    while (true) {\r\n        const action = yield take(actionTypes.CHANGE);\r\n        if (task) {\r\n            yield cancel(task);\r\n        }\r\n        task = yield fork(updateDataInServer, action);\r\n    }\r\n\r\n}\r\n\r\nfunction* updateDataInServer(action) {\r\n    try {\r\n        // debounce 300 ms\r\n        yield call(delay, 300);\r\n\r\n       //retrieve key from the store\r\n        const key = yield select(selectors.getKey);\r\n        const newSettings = yield select(selectors.getSettingsItems);\r\n\r\n        const response = yield call(serverSettings.update, newSettings, key);\r\n        const responseKey = serverSelectors.getKey(response);\r\n       // dispatch action with responseKey, which is stored for later user\r\n        yield put(actions.saved(responseKey));\r\n\r\n    } \r\n//...\r\n }\r\n```\r\n\r\nThe issue is that my server returns a distinct key in every response that it makes. In order to be able to call the server, I must provide it the latest key in my request, which I maintain inside myStore (see above `const key = yield select(selectors.getKey)`).\r\n\r\nThe problem occurs when the cancellation is done before the response from the server is received. \r\nWhat happens is that the request had already gone out (thus a new key has been provided), but by the time the response arrives the task is already cancelled, and thus the response key is never stored, and it is not possible to send any more requests.\r\n\r\nAfter investigating the issue, I decided to go with `spawn` in order to insure an all-or-nothing- approach. If the task is cancelled before the request has gone out then it will be ignored, however if the request had occurred, the entire process will happen. So `updateDataInServer` now looks like this:\r\n\r\n```javascript\r\n try {\r\n      // debounce 300 ms\r\n        yield call(delay, 300);\r\n\r\n        const key = yield select(selectors.getKey);\r\n        const newSettings = yield select(selectors.getSettingsItems);\r\n\r\n         yield spawn(function*() {\r\n               const response = yield call(serverSettings.update, newSettings, key);\r\n               const responseKey = serverSelectors.getKey(response);\r\n               yield put(actions.saved(responseKey));\r\n        });\r\n\r\n    } \r\n//...\r\n```\r\n\r\nI was wondering whether this is the correct approach. @yelouafi - I would appreciate your feedback.\r\nI upgraded from version 0.95 in order to get `spawn` because I could not find a different way to solve this issue. Can the behavior I want be achieved with that version?\r\n\r\nThanks"
    }
  },
  "public" : true,
  "created_at" : "2016-12-05T10:11:10Z"
} ]